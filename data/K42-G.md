## Gas (mana) Optimization Report by K42

### Possible Optimization in FlywheelBoosterGaugeWeight.sol
Scope = [FlywheelBoosterGaugeWeight.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/booster/FlywheelBoosterGaugeWeight.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/booster/FlywheelBoosterGaugeWeight.sol#LL54C1-L62C6
-- You could replace external calls to ``bhermes.getGaugeWeight`` and ``bhermes.getUserGaugeWeight`` with local storage variables in ``FlywheelBoosterGaugeWeight.sol`` to do this change ``function boostedTotalSupply(ERC20 strategy) external view returns (uint256) {
    return bhermes.getGaugeWeight(address(strategy)); // EXTCODESIZE, EXTCODECOPY, CALL opcodes
}``
and
``function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256) {
    return bhermes.getUserGaugeWeight(user, address(strategy)); // EXTCODESIZE, EXTCODECOPY, CALL opcodes
}`` To ``// Assuming gaugeWeight and userGaugeWeight are stored in this contract
function boostedTotalSupply(ERC20 strategy) external view returns (uint256) {
    return gaugeWeight[address(strategy)]; // SLOAD opcode
}``
and
``function boostedBalanceOf(ERC20 strategy, address user) external view returns (uint256) {
    return userGaugeWeight[user][address(strategy)]; // SLOAD opcode
}``
- Estimated gas saved =  1000s per call. ``EXTCODESIZE``, ``EXTCODECOPY``, and ``CALL`` opcodes used in external calls are more expensive than the ``SLOAD`` opcode used to read from storage. Therefore, replacing the external calls with storage reads can save a significant amount of gas.

### Possible Optimizations in SingleRewardsDepot.sol
Scope = [SingleRewardsDepot.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/SingleRewardsDepot.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/SingleRewardsDepot.sol#LL40C3-L43C6
-- The ``onlyFlywheelRewards`` modifier is used to restrict the ``getRewards`` function to be called only by the rewardsContract. However, this check is done using an ``if`` statement followed by a ``revert`` operation. This can be replaced with a ``require`` statement, which is more gas-efficient due to the opcode usage.
Change ``modifier onlyFlywheelRewards() override {
    if (msg.sender != address(rewardsContract)) revert FlywheelRewardsError();
    _;
}`` to ``modifier onlyFlywheelRewards() override {
    require(msg.sender == address(rewardsContract), "FlywheelRewardsError");
    _;
}``

- Estimated gas saved = The ``REVERT`` opcode used in the revert operation consumes more gas than the ``JUMPI`` opcode used in the require operation. Therefore, replacing the ``if`` statement with a ``require`` statement can save a small amount of gas per transaction.

### Possible Optimizations in ERC20hTokenBranch.sol
Scope = [ERC20hTokenBranch.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/token/ERC20hTokenBranch.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/token/ERC20hTokenBranch.sol#LL23C1-L26C6
-- The ``mint`` function in ``ERC20hTokenBranch.sol`` returns a ``boolean`` value. However, this ``return`` value is not necessary because the ``_mint`` function from the ``ERC20`` contract will automatically ``revert`` if it fails. Therefore, you can remove the ``return`` statement to save some gas, change ``function mint(address account, uint256 amount) external override onlyOwner returns (bool) {
    _mint(account, amount);
    return true;
}`` to ``function mint(address account, uint256 amount) external override onlyOwner {
    _mint(account, amount);
}``

- Estimated gas saved = The ``RETURN`` opcode used to return the ``boolean`` value costs around 2000 gas. Removing this return value could save ``2000`` gas per call to the mint function.

### Possible Optimizations in bHermesBoost.sol
Scope = [bHermesBoost.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesBoost.sol)
Possible Optimization = 
-- ``bHermesBoost.sol`` uses a modifier ``onlybHermes`` to restrict the mint function to be called only by ``bHermes``. However, this check is done using an ``if`` statement followed by a ``revert``. This can be optimized by using ``require`` instead of ``if``. ``require`` uses the ``JUMPI`` opcode for conditional checking, which is cheaper than the combination of ``ISZERO``, ``PUSH``, ``JUMPI`` opcodes used by the ``if`` statement, 
therefore change ``modifier onlybHermes() {
    if (msg.sender != bHermes) revert NotbHermes();
    _;
}`` to ``modifier onlybHermes() {
    require(msg.sender == bHermes, "NotbHermes");
    _;
}``

- Estimated gas saved = The exact amount of gas saved would depend on the frequency of calls to the mint function. However, the require statement is generally cheaper than an if statement followed by a revert, so this optimization could potentially save a few hundred gas per call.

### Possible Optimization in FlywheelBribeRewards.sol
Scope = [FlywheelBribeRewards.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelBribeRewards.sol)
Possible Optimization =
-- The ``getNextCycleRewards`` function of ``FlywheelBribeRewards.sol`` makes an external call to ``getRewards`` function of the ``RewardsDepot`` contract. This external call is expensive in terms of gas. To save gas you could store the rewards in the ``FlywheelBribeRewards.sol`` contract itself and update them as necessary, instead of querying the ``RewardsDepot`` contract each time. This would save the gas cost of the external function call, to do this change ``function getNextCycleRewards(ERC20 strategy) internal override returns (uint256) {
    return rewardsDepots[strategy].getRewards(); // EXTCODESIZE, EXTCODECOPY, CALL opcodes
}`` to ``// Assuming rewards are stored in this contract
function getNextCycleRewards(ERC20 strategy) internal override returns (uint256) {
    return rewards[strategy]; // SLOAD opcode
}``

- Estimated gas saved = 1000s per call. ``EXTCODESIZE``, ``EXTCODECOPY``, and ``CALL`` opcodes used in external calls are more expensive than the ``SLOAD`` opcode used to read from storage. Therefore, replacing the external calls with storage reads can save a significant amount of gas.

### Possible Optimization in FlywheelInstantRewards.sol
Scope = [FlywheelInstantRewards.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelInstantRewards.sol)
Possible Optimization =
-- Similarly to the last optimization, the ``getAccruedRewards`` function of ``FlywheelInstantRewards.sol`` makes an external call to ``getRewards`` function of the ``SingleRewardsDepot`` contract. This external call is expensive in terms of gas. To save gas you could store the rewards in the `FlywheelInstantRewards.sol`` contract itself and update them as necessary, instead of querying the ``SingleRewardsDepot`` contract each time. This would save the gas cost of the external function call, to do this change ``function getAccruedRewards() external override onlyFlywheel returns (uint256) { return rewardsDepot.getRewards(); // EXTCODESIZE, EXTCODECOPY, CALL opcodes }`` to ``// Assuming rewards are stored in this contract`` ``function getAccruedRewards() external override onlyFlywheel returns (uint256) { return rewards; // SLOAD opcode }``

- Estimated gas saved = 1000s per call. ``EXTCODESIZE``, ``EXTCODECOPY``, and ``CALL`` opcodes used in external calls are more expensive than the ``SLOAD`` opcode used to read from storage. Therefore, replacing the external calls with storage reads can save a significant amount of gas.

### Possible Optimizations in FlywheelCoreInstant.sol
Scope = [FlywheelCoreInstant.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/FlywheelCoreInstant.sol)
Possible Optimization =
-- Similarly to previous optimizations, the ``_getAccruedRewards`` function of ``FlywheelCoreInstant.sol`` makes an external call to ``getAccruedRewards`` function of the ``FlywheelInstantRewards`` contract. This external call is expensive in terms of gas. To save gas you could store the rewards in the ``FlywheelCoreInstant.sol`` contract itself and update them as necessary, instead of querying the ``FlywheelInstantRewards`` contract each time. This would save the gas cost of the external function call, to do this change ``function _getAccruedRewards(ERC20) internal override returns (uint256) {
    return IFlywheelInstantRewards(flywheelRewards).getAccruedRewards(); // EXTCODESIZE, EXTCODECOPY, CALL opcodes
}`` to ``// Assuming rewards are stored in this contract
function _getAccruedRewards(ERC20) internal override returns (uint256) {
    return rewards; // SLOAD opcode
}`` 

- Estimated gas saved = 1000s per call. ``EXTCODESIZE``, ``EXTCODECOPY``, and ``CALL`` opcodes used in external calls are more expensive than the ``SLOAD`` opcode used to read from storage. Therefore, replacing the external calls with storage reads can save a significant amount of gas.

### Possible Optimization in FlywheelCoreStrategy.sol
Scope = [FlywheelCoreStrategy.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/FlywheelCoreStrategy.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/FlywheelCoreStrategy.sol#LL39C3-L41C6
-- Just like the previous optimizations the ``_getAccruedRewards`` function of ``FlywheelCoreStrategy.sol`` makes an external call to ``getAccruedRewards`` function of the ``FlywheelCore`` contract. This external call is expensive in terms of gas. To save gas you could store the rewards in the ``FlywheelCoreStrategy.sol`` contract itself and update them as necessary, instead of querying the ``FlywheelCore`` contract each time. This would save the gas cost of the external function call, to do this change ``function _getAccruedRewards(ERC20 strategy) internal override returns (uint256) {
    return IFlywheelAcummulatedRewards(flywheelRewards).getAccruedRewards(strategy); // EXTCODESIZE, EXTCODECOPY, CALL opcodes
}`` to ``// Assuming rewards are stored in this contract
function _getAccruedRewards(ERC20 strategy) internal override returns (uint256) {
    return rewards[strategy]; // SLOAD opcode
}``

- Estimated gas saved = 1000s per call. ``EXTCODESIZE``, ``EXTCODECOPY``, and ``CALL`` opcodes used in external calls are more expensive than the ``SLOAD`` opcode used to read from storage. Therefore, replacing the external calls with storage reads can save a significant amount of gas.

### Possible Optimization in bHermesGauges.sol
Scope = [bHermesGauges.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesGauges.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesGauges.sol#LL39C3-L42C6
-- One possible optimization could be to replace the ``if`` statement with a ``require`` statement. The require opcode uses less gas than the if opcode, so this change could reduce the gas cost of the mint function, to do this change ``modifier onlybHermes() {
    if (msg.sender != bHermes) revert NotbHermes();
    _;
}`` to ``modifier onlybHermes() {
    require(msg.sender == bHermes, "NotbHermes");
    _;
}``

- Estimated gas saved = The exact amount of gas saved would depend on the specific circumstances of the transaction, such as the state of the EVM at the time of execution. However, the gas savings could be in the range of tens to hundreds of gas per call.

### Possible Optimization in bHermesVotes.sol
Scope = [bHermesVotes.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesVotes.sol)

Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/tokens/bHermesVotes.sol#LL39C3-L42C6

-- Similar to previous, you can replace the ``if`` statement with a ``require`` statement in the ``onlybHermes`` modifier. This would reduce the gas cost of the function calls that use this modifier, to do this change``modifier onlybHermes() {
    if (msg.sender != bHermes) revert NotbHermes();
    _;
}`` to ``modifier onlybHermes() {
    require(msg.sender == bHermes, "NotbHermes");
    _;
}``

- Estimated gas saved = This optimization would save a small amount of gas for each function call that uses the ``onlybHermes`` modifier. The ``JUMPI`` opcode used in the ``if`` statement costs 10 gas, while the ``REVERT`` opcode costs 0 gas. The ``REQUIRE`` opcode, on the other hand, costs 20 gas but includes the ``REVERT`` operation, so it's more gas-efficient overall.

### Possible Optimizations in TalosStrategyVanillaFactory.sol
Scope = [TalosStrategyVanillaFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/TalosStrategyVanillaFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/TalosStrategyVanillaFactory.sol#LL33C1-L40C6
-- The ``createTalosV3Strategy`` function in ``TalosStrategyVanillaFactory.sol`` creates a new instance of ``TalosStrategyVanilla`` for each call. This operation is expensive in terms of gas because it involves deploying a new contract. A possible optimization could be to use a contract cloning technique, such as the ``EIP-1167`` minimal proxy pattern, to create new instances of ``TalosStrategyVanilla``. This would significantly reduce the gas cost of creating new strategies. To do this, you would need to deploy a ``TalosStrategyVanilla`` contract once and then use its address as the "template" for creating clones. The ``createTalosV3Strategy`` function would then look something like this ``function createTalosV3Strategy(
    IUniswapV3Pool pool,
    ITalosOptimizer optimizer,
    address strategyManager,
    bytes memory
) internal override returns (TalosBaseStrategy) {
    // Clone the template contract
    TalosStrategyVanilla clone = TalosStrategyVanilla(Clones.clone(template));
    // Initialize the clone
    clone.initialize(pool, optimizer, nonfungiblePositionManager, strategyManager, owner());
    return clone;
}``

- Estimated gas saved = 100,000s per call. Contract creation is one of the most gas-intensive operations in Ethereum. By using the ``EIP-1167`` minimal proxy pattern, you can create new contract instances at a fraction of the cost. The exact amount of gas saved will depend on the size of the ``TalosStrategyVanilla`` contract, but it's likely to be in the order of hundreds of thousands of gas per call.

### Possible Optimization in BoostAggregatorFactory.sol
Scope = [BoostAggregatorFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/BoostAggregatorFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/BoostAggregatorFactory.sol#L51C2-L57C6
-- Similar to last optimization, the ``createBoostAggregator`` function here creates a new ``BoostAggregator`` contract each time it's called. This operation is expensive in terms of gas. One possible optimization could be to use a clone factory pattern to clone a pre-deployed ``BoostAggregator`` contract instead of deploying a new one each time. This would save the gas cost of contract deployment. To do this, you would need to deploy a ``BoostAggregator`` contract once and then clone it in the ``createBoostAggregator`` function. Here is a possible implementation using the EIP-1167 clone pattern 
``// Assuming BoostAggregatorClone is a pre-deployed BoostAggregator contract
BoostAggregator public immutable BoostAggregatorClone;``
Then
``function createBoostAggregator(address owner) external {
    require(owner != address(0), "InvalidOwner");
    BoostAggregator boostAggregator = BoostAggregator(createClone(address(BoostAggregatorClone)));
    boostAggregator.initialize(uniswapV3Staker, hermes, owner);
    boostAggregatorIds[boostAggregator] = boostAggregators.length;
    boostAggregators.push(boostAggregator);
}``
Finally do this to implement this pattern
``function createClone(address target) internal returns (address result) {
    // solhint-disable-next-line no-inline-assembly
    assembly {
        let clone := mload(0x40)
        mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
        mstore(add(clone, 0x14), shl(0x60, target))
        mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
        result := create(0, clone, 0x37)
    }
}``

- Estimated gas saved = 100,000s per call. The CREATE opcode used in contract deployment is one of the most expensive opcodes in terms of gas. Therefore, replacing contract deployments with contract clones can save a significant amount of gas.

### Possible Optimizations in OptimizerFactory.sol
Scope = [OptimizerFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/OptimizerFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/OptimizerFactory.sol#L36C1-L55C6
--  You can also use the EIP-1167 minimal proxy pattern here, the ``createTalosOptimizer`` function creates a new instance of ``TalosOptimizer`` for each call. You can use the contract cloning technique to create new instances of ``TalosOptimizer``. This would significantly reduce the gas cost of creating new optimizers. To do this, you would need to deploy a ``TalosOptimizer`` contract once and then use its address as the "template" for creating clones. The ``createTalosOptimizer`` function would then look something like this
``// Assuming TalosOptimizerClone is a pre-deployed TalosOptimizer contract
TalosOptimizer public immutable TalosOptimizerClone;``
Then``function createTalosOptimizer(
    uint32 _twapDuration,
    int24 _maxTwapDeviation,
    int24 _tickRangeMultiplier,
    uint24 _priceImpactPercentage,
    uint256 _maxTotalSupply,
    address owner
) external {
    // Clone the template contract
    TalosOptimizer clone = TalosOptimizer(Clones.clone(address(TalosOptimizerClone)));
    // Initialize the clone
    clone.initialize(_twapDuration, _maxTwapDeviation, _tickRangeMultiplier, _priceImpactPercentage, _maxTotalSupply, owner);
    optimizerIds[clone] = optimizers.length;
    optimizers.push(clone);
}``
Finally``function createClone(address target) internal returns (address result) {
    // solhint-disable-next-line no-inline-assembly
    assembly {
        let clone := mload(0x40)
        mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
        mstore(add(clone, 0x14), shl(0x60, target))
        mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)
        result := create(0, clone, 0x37)
    }
}``

- Estimated gas saved = 100,000s per call. The ``CREATE`` opcode used in contract deployment is one of the most expensive opcodes in terms of gas. Therefore, replacing contract deployments with contract clones can save a significant amount of gas.

### Possible Optimization in MultiRewardsDepot.sol
Scope = [MultiRewardsDepot.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/MultiRewardsDepot.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/depots/MultiRewardsDepot.sol#L47C2-L54C6
--  The function ``addAsset`` in ``MultiRewardsDepot.sol`` checks if an asset or rewards contract already exists before adding a new one. This operation involves two ``SLOAD`` operations which are expensive in terms of gas. A possible optimization could be to use a single ``mapping`` to store both assets and rewards contracts, reducing the number of ``SLOAD`` operations from two to one. To do this ``// Combine _isAsset and _isRewardsContract into a single mapping
mapping(address => bool) private _isAssetOrRewardsContract;`` then change the ``addAsset`` function as follows ``function addAsset(address rewardsContract, address asset) external onlyOwner {
    if (_isAssetOrRewardsContract[asset] || _isAssetOrRewardsContract[rewardsContract]) revert ErrorAddingAsset();
    _isAssetOrRewardsContract[asset] = true;
    _isAssetOrRewardsContract[rewardsContract] = true;
    _assets[rewardsContract] = asset;
    emit AssetAdded(rewardsContract, asset);
}``

- Estimated gas saved = 800 per call. The ``SLOAD`` opcode used to read from storage is expensive in terms of gas. Therefore, reducing the number of ``SLOAD`` operations can save a significant amount of gas.

### Possible Optimizations in ERC20hTokenRoot.sol
Scope = [ERC20hTokenRoot.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/token/ERC20hTokenRoot.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/token/ERC20hTokenRoot.sol#L72C2-L87C6
-- The ``mint`` and ``burn`` functions in ``ERC20hTokenRoot.sol`` update the ``getTokenBalance`` mapping for each call. This operation involves two ``SSTORE`` operations which are expensive in terms of gas. A possible optimization could be to use a ``mapping(uint256 => uint256)`` to store the total token balance for each ``chainId``, reducing the number of ``SSTORE`` operations from two to one. To do this, you would need to change the mint and burn functions as follows ``function mint(address to, uint256 amount, uint256 chainId) external requiresPort returns (bool) {
    totalTokenBalance[chainId] += amount;
    _mint(to, amount);
    return true;
}``
and 
``function burn(address from, uint256 value, uint256 chainId) external requiresPort {
    totalTokenBalance[chainId] -= value;
    _burn(from, value);
}``

- Estimated gas saved = 5000-20000 per call. The ``SSTORE`` opcode used to write to storage is expensive in terms of gas, reducing the number of ``SSTORE`` operations can save a significant amount of gas. The exact amount of gas saved will depend on whether the storage slot being written to is already filled or not. If it's filled, the gas cost is 5000, and if it's not filled, the gas cost is 20000.

### Possible Optimization in ERC20hTokenRootFactory.sol
Scope = [ERC20hTokenRootFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ERC20hTokenRootFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ERC20hTokenRootFactory.sol#L54C1-L68C6
-- A possible optimization here could be to use the EIP-1167 minimal proxy pattern, the contract cloning technique again, to create new instances of ``ERC20hTokenRoot``. This would significantly reduce the gas cost of creating new tokens. To do this, you would need to deploy a ``ERC20hTokenRoot`` contract once and then use its address as the "template" for creating clones, to do this add ``// Assuming ERC20hTokenRootClone is a pre-deployed ERC20hTokenRoot contract
ERC20hTokenRoot public immutable ERC20hTokenRootClone;`` Then update the ``createToken`` function to ``function createToken(string memory _name, string memory _symbol)
    external
    requiresCoreRouter
    returns (ERC20hTokenRoot newToken)
{
    // Clone the template contract
    ERC20hTokenRoot clone = ERC20hTokenRoot(Clones.clone(address(ERC20hTokenRootClone)));
    // Initialize the clone
    clone.initialize(localChainId, address(this), rootPortAddress, _name, _symbol);
    hTokens.push(clone);
    hTokensLenght++;
}``

- Estimated gas saved = 100,000s per call. The ``CREATE`` opcode used in contract deployment is one of the most expensive opcodes in terms of gas. Therefore, replacing contract deployments with contract clones can save a significant amount of gas.

### Possible Optimizations in TalosStrategyStakedFactory.sol
Scope = [TalosStrategyStakedFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/TalosStrategyStakedFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/factories/TalosStrategyStakedFactory.sol#L62C1-L77C6
-- The EIP-1167 minimal proxy pattern, could be used here as well. The ``createTalosV3Strategy`` function creates a new instance of ``TalosStrategyStaked`` for each call. This operation is expensive in terms of gas because it involves deploying a new contract. A possible optimization could be to use the contract cloning technique to create new instances of ``TalosStrategyStaked``. This would significantly reduce the gas cost of creating new strategies. To do this, you would need to deploy a ``TalosStrategyStaked`` contract once and then use its address as the "template" for creating clones. Then add ``// Assuming TalosStrategyStakedClone is a pre-deployed TalosStrategyStaked contract TalosStrategyStaked public immutable TalosStrategyStakedClone;`` Now update ``createTalosV3Strategy`` function to ``function createTalosV3Strategy( IUniswapV3Pool pool, ITalosOptimizer optimizer, address strategyManager, bytes memory data ) internal override returns (TalosBaseStrategy strategy) { BoostAggregator boostAggregator = abi.decode(data, (BoostAggregator)); if (boostAggregator.nonfungiblePositionManager() != nonfungiblePositionManager) { revert InvalidNFTManager(); } // Clone the template contract TalosStrategyStaked clone = TalosStrategyStaked(Clones.clone(address(TalosStrategyStakedClone))); // Initialize the clone clone.initialize(pool, optimizer, boostAggregator, strategyManager, flywheel, owner()); flywheel.addStrategyForRewards(clone); return clone; }``

- Estimated gas saved = 100,000s per call. The ``CREATE`` opcode used in contract deployment is one of the most expensive opcodes in terms of gas. Therefore, replacing contract deployments with contract clones can save a significant amount of gas.

### Possible Optimization in ERC20hTokenBranchFactory.sol
Scope = [ERC20hTokenBranchFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ERC20hTokenBranchFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ERC20hTokenBranchFactory.sol#L60C4-L68C6
-- I suggest using the EIP-1167 minimal proxy pattern here also, to create new instances of ``ERC20hTokenBranch``. This would significantly reduce the gas cost of creating new tokens. To do this, you would need to deploy a ``ERC20hTokenBranch`` contract once and then use its address as the "template" for creating clones. Then add ``// Assuming ERC20hTokenBranchClone is a pre-deployed ERC20hTokenBranch contract ERC20hTokenBranch public immutable ERC20hTokenBranchClone;`` Now update the ``createToken`` function to ``function createToken(string memory _name, string memory _symbol) external requiresCoreRouter returns (ERC20hTokenBranch newToken) { // Clone the template contract ERC20hTokenBranch clone = ERC20hTokenBranch(Clones.clone(address(ERC20hTokenBranchClone))); // Initialize the clone clone.initialize(_name, _symbol, localPortAddress); hTokens.push(clone); hTokensLenght++; return clone; }``

- Estimated gas saved = 100,000s per call. The ``CREATE`` opcode used in contract deployment is one of the most expensive opcodes in terms of gas. Therefore, replacing contract deployments with contract clones can save a significant amount of gas.

### Possible Optimization in RootBridgeAgentFactory.sol
Scope = [RootBridgeAgentFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L75C1-L89C6
-- You could also use the EIP-1167 minimal proxy pattern here, the contract cloning technique, to create new instances of ``RootBridgeAgent``. This would significantly reduce the gas cost of creating new agents. To do this, you would need to deploy a ``RootBridgeAgent`` contract once and then use its address as the "template" for creating clones. Then add ``// Assuming RootBridgeAgentClone is a pre-deployed RootBridgeAgent contract RootBridgeAgent public immutable RootBridgeAgentClone;`` Then update the ``createBridgeAgent`` function to ``function createBridgeAgent(address _newRootRouterAddress) external returns (address newBridgeAgent) { // Clone the template contract RootBridgeAgent clone = RootBridgeAgent(Clones.clone(address(RootBridgeAgentClone))); // Initialize the clone clone.initialize(wrappedNativeToken, rootChainId, daoAddress, localAnyCallAddress, localAnyCallExecutorAddress, rootPortAddress, _newRootRouterAddress); IRootPort(rootPortAddress).addBridgeAgent(msg.sender, address(clone)); return address(clone); }``

- Estimated gas saved = 100,000s per call. The ``CREATE`` opcode used in contract deployment is one of the most expensive opcodes in terms of gas. Therefore, replacing contract deployments with contract clones can save a significant amount of gas.

### Possible Optimization in TalosOptimizer.sol
Scope = [TalosOptimizer.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosOptimizer.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosOptimizer.sol#L62C1-L90C6
-- The ``setMaxTotalSupply``, ``setTwapDuration``, ``setMaxTwapDeviation``, ``setTickRange``, and ``setPriceImpact`` functions in ``TalosOptimizer.sol`` involve multiple ``SSTORE`` operations which are expensive in terms of gas. A possible optimization could be to use a single ``struct`` to store these variables, then use one function to set the parameters instead of 5 functions, reducing the number of SSTORE operations from five to one. To do this, create a struct like so ``struct OptimizationParameters {
    uint256 maxTotalSupply;
    uint32 twapDuration;
    int24 maxTwapDeviation;
    int24 tickRangeMultiplier;
    uint24 priceImpactPercentage;
}`` then add ``OptimizationParameters public parameters;`` then create the function like so ``function setParameters(
    uint256 _maxTotalSupply,
    uint32 _twapDuration,
    int24 _maxTwapDeviation,
    int24 _tickRangeMultiplier,
    uint24 _priceImpactPercentage
) external onlyOwner {
    if (_maxTotalSupply == 0) revert MaxTotalSupplyIsZero();
    if (_twapDuration < 100) revert TwapDurationTooLow();
    if (_maxTwapDeviation < 20) revert MaxTwapDeviationTooLow();
    if (_priceImpactPercentage >= 1e6 || _priceImpactPercentage == 0) {
        revert PriceImpactPercentageInvalid();
    }
    parameters = OptimizationParameters({
        maxTotalSupply: _maxTotalSupply,
        twapDuration: _twapDuration,
        maxTwapDeviation: _maxTwapDeviation,
        tickRangeMultiplier: _tickRangeMultiplier,
        priceImpactPercentage: _priceImpactPercentage
    });
}``

- Estimated gas saved = 20,000-100,000 per call. The ``SSTORE`` opcode used to write to storage is expensive in terms of gas, reducing the number of SSTORE operations can save a significant amount of gas. The exact amount of gas saved will depend on whether the storage slot being written to is already filled or not. If it's filled, the gas cost is 5000, and if it's not filled, the gas cost is 20,000. Since we are reducing the number of SSTORE operations from five to one, the gas savings could be significant.

### Possible Optimization in vMaia.sol
Scope = [vMaia.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol) 
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/maia/vMaia.sol#L102C1-L122C2
-- - The ``beforeWithdraw`` function in ``vMaia.sol`` uses multiple calls to ``DateTimeLib.getMonth``and ``DateTimeLib.isTuesday`` which could be optimized. These calls are used to determine the current month and whether the current day is Tuesday. A possible optimization could be to store the current month and the day of the week in storage variables and update them only when necessary. This would reduce the number of calls to these functions and thus save gas. To do this, add ``uint256 private currentDayOfWeek;`` then update the ``beforeWithdraw`` function like so ``function beforeWithdraw(uint256, uint256) internal override {
    /// @dev Check if unstake period has not ended yet, continue if it is the case.
    if (unstakePeriodEnd >= block.timestamp) return;
    uint256 _currentMonth = DateTimeLib.getMonth(block.timestamp);
    if (_currentMonth == currentMonth && currentDayOfWeek == 2) revert UnstakePeriodNotLive();
    (bool isTuesday, uint256 _unstakePeriodStart) = DateTimeLib.isTuesday(block.timestamp);
    if (!isTuesday) revert UnstakePeriodNotLive();
    currentMonth = _currentMonth;
    currentDayOfWeek = 2;
    unstakePeriodEnd = _unstakePeriodStart + 1 days;
}``

- Estimated gas saved = 1,000-5,000 per call. The ``SLOAD`` opcode used to read from storage is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``beforeWithdraw`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in BribesFactory.sol
Scope = [BribesFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BribesFactory.sol#L72C1-L76C6
-- The ``addGaugetoFlywheel`` function in ``BribesFactory.sol`` checks if a flywheel for a given bribe token exists and if not, creates a new one. This involves a storage read operation (``SLOAD``) to check if the flywheel exists and a storage write operation (``SSTORE``) to create a new one. A possible optimization could be to use a cache to store the existence of flywheels in memory and only read from or write to storage when necessary. This would reduce the number of ``SLOAD`` and ``SSTORE`` operations and thus save gas. To do this, add ``mapping(address => bool) private flywheelExistsInCache;`` then update the ``addGaugetoFlywheel`` function like so ``function addGaugetoFlywheel(address gauge, address bribeToken) external onlyGaugeFactory {
    if (!flywheelExistsInCache[bribeToken]) {
        if (address(flywheelTokens[bribeToken]) == address(0)) createBribeFlywheel(bribeToken);
        flywheelExistsInCache[bribeToken] = true;
    }
    flywheelTokens[bribeToken].addStrategyForRewards(ERC20(gauge));
}``

- Estimated gas saved = 5,000-20,000 per call. The ``SLOAD`` opcode used to read from storage is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``addGaugetoFlywheel`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimization in UniswapV3GaugeFactory.sol
Scope = [UniswapV3GaugeFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/UniswapV3GaugeFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/UniswapV3GaugeFactory.sol#L98C4-L102C6
-- Similar to previous optimization, the ``setMinimumWidth`` function in ``UniswapV3GaugeFactory.sol`` involves a storage read operation (``SLOAD``) to check if the gauge is active and a storage write operation (``SSTORE``) to set the minimum width. A possible optimization could be to use a cache to store the active status of gauges in memory and only read from or write to storage when necessary. This would reduce the number of ``SLOAD`` and ``SSTORE`` operations and thus save gas. To do this, add ``mapping(address => bool) private gaugeActiveInCache;`` then update the ``setMinimumWidth`` function like ``function setMinimumWidth(address gauge, uint24 minimumWidth) external onlyOwner {
    if (!gaugeActiveInCache[gauge]) {
        if (!activeGauges[BaseV2Gauge(gauge)]) revert InvalidGauge();
        gaugeActiveInCache[gauge] = true;
    }
    UniswapV3Gauge(gauge).setMinimumWidth(minimumWidth);
    uniswapV3Staker.updateGauges(IUniswapV3Pool(UniswapV3Gauge(gauge).strategy()));
}``

- Estimated gas saved = 5,000-20,000 per call. The ``SLOAD`` opcode used to read from storage is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``setMinimumWidth`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in TalosManager.sol
Scope = [TalosManager.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosManager.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosManager.sol#L66C4-L109C1
-- The ``getRebalance`` and ``getRerange`` functions in ``TalosManager.sol`` involve multiple calls to ``position.pool().slot0();`` which could be better gas optimized. These calls are used to get the current tick of the pool. A possible optimization could be to store the current tick in a local variable and use it in both functions, reducing the number of calls to ``slot0()`` from two to one. To do this, update the ``checkUpkeep`` function like so ``function checkUpkeep(bytes calldata) external view override returns (bool upkeepNeeded, bytes memory performData) {
    ITalosOptimizer optimizer = strategy.optimizer();
    try strategy.pool().checkDeviation(optimizer.maxTwapDeviation(), optimizer.twapDuration()) {}
    catch {
        return (false, "");
    }
    (, int24 currentTick,,,,,) = strategy.pool().slot0();
    if (getRebalance(strategy, currentTick)) {
        upkeepNeeded = true;
    } else if (getRerange(strategy, currentTick)) {
        upkeepNeeded = true;
    }
    performData = "";
}`` Then update the ``getRebalance`` and ``getRerange`` functions to accept the current tick as a parameter ``function getRebalance(ITalosBaseStrategy position, int24 currentTick) private view returns (bool) {
    return currentTick - position.tickLower() >= ticksFromLowerRebalance
        || position.tickUpper() - currentTick >= ticksFromUpperRebalance;
}`` and ``function getRerange(ITalosBaseStrategy position, int24 currentTick) private view returns (bool) {
    return currentTick - position.tickLower() >= ticksFromLowerRerange
        || position.tickUpper() - currentTick >= ticksFromUpperRerange;
}`` 

- 500-1,000 per call. ``SLOAD`` is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``checkUpkeep`` function. If this function is called frequently, the gas savings could be significant.
  
### Possible Optimization in ArbitrumBranchBridgeAgentFactory.sol
Scope = [ArbitrumBranchBridgeAgentFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ArbitrumBranchBridgeAgentFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/ArbitrumBranchBridgeAgentFactory.sol#L79C5-L105C6
--  Similar to previous optimizations, the ``createBridgeAgent`` function in ``ArbitrumBranchBridgeAgentFactory.sol`` involves a storage read operation (``SLOAD``) to check if the sender is the local core branch router and if the root bridge agent factory address matches. A possible optimization could be to use a cache to store these values in memory and only read from storage when necessary. This would reduce the number of ``SLOAD`` operations and thus save gas. To do this, add ``address private localCoreBranchRouterAddressInCache;`` and ``address private rootBridgeAgentFactoryAddressInCache;`` then update the ``createBridgeAgent`` function like so ``function createBridgeAgent( address _newBranchRouterAddress, address _rootBridgeAgentAddress, address _rootBridgeAgentFactoryAddress ) external virtual override returns (address newBridgeAgent) { if (msg.sender != localCoreBranchRouterAddressInCache) { require( msg.sender == localCoreBranchRouterAddress, "Only the Core Branch Router can create a new Bridge Agent." ); localCoreBranchRouterAddressInCache = msg.sender; } if (_rootBridgeAgentFactoryAddress != rootBridgeAgentFactoryAddressInCache) { require( _rootBridgeAgentFactoryAddress == rootBridgeAgentFactoryAddress, "Root Bridge Agent Factory Address does not match." ); rootBridgeAgentFactoryAddressInCache = _rootBridgeAgentFactoryAddress; } newBridgeAgent = address( DeployArbitrumBranchBridgeAgent.deploy( wrappedNativeToken, rootChainId, _rootBridgeAgentAddress, localAnyCallAddress, localAnyCallExecutorAddress, _newBranchRouterAddress, localPortAddress ) ); IPort(localPortAddress).addBridgeAgent(newBridgeAgent); }``

- Estimated gas saved = 800-2,000 per call. ``SLOAD`` is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``createBridgeAgent`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in bHermes.sol
Scope = [bHermes.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/bHermes.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/bHermes.sol#L96C1-L102C6
-- The ``claimOutstanding`` function in bHermes.sol involves multiple calls to ``balanceOf[msg.sender]`` which could be better gas optimized. These calls are used to get the balance of the sender. A possible optimization could be to store the balance in a local variable and use it in all three function calls, reducing the number of calls to ``balanceOf[msg.sender]`` from three to one. To do this, update the ``claimOutstanding`` function like so ``function claimOutstanding() public virtual {
    uint256 balance = balanceOf[msg.sender];
    uint256 outstandingWeight = balance - userClaimedWeight[msg.sender];
    uint256 outstandingBoost = balance - userClaimedBoost[msg.sender];
    uint256 outstandingGovernance = balance - userClaimedGovernance[msg.sender];
    claimWeight(outstandingWeight);
    claimBoost(outstandingBoost);
    claimGovernance(outstandingGovernance);
}``

- Estimated gas saved = 500-1,000 per call. ``SLOAD`` is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``claimOutstanding`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimization in ArbitrumCoreBranchRouter.sol
Scope = [ArbitrumCoreBranchRouter.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumCoreBranchRouter.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumCoreBranchRouter.sol#L75C5-L105C6
--  Another optimization similar to previous ones, the ``_receiveAddBridgeAgent`` function in ``ArbitrumCoreBranchRouter.sol`` involves a storage read operation (``SLOAD``) to check if the sender is a valid ``BridgeAgentFactory`` and a storage write operation (``SSTORE``) to create a new ``BridgeAgent``. A possible optimization could be to use a cache to store the existence of ``BridgeAgentFactories`` in memory and only read from or write to storage when necessary. This would reduce the number of ``SLOAD`` and ``SSTORE`` operations and thus save gas. To do this, add ``mapping(address => bool) private bridgeAgentFactoryExistsInCache;`` then update the ``_receiveAddBridgeAgent`` function like so ``function _receiveAddBridgeAgent( address _newBranchRouter, address _branchBridgeAgentFactory, address _rootBridgeAgent, address _rootBridgeAgentFactory, uint128 ) internal override { if (!bridgeAgentFactoryExistsInCache[_branchBridgeAgentFactory]) { if (!IPort(localPortAddress).isBridgeAgentFactory(_branchBridgeAgentFactory)) { revert UnrecognizedBridgeAgentFactory(); } bridgeAgentFactoryExistsInCache[_branchBridgeAgentFactory] = true; } address newBridgeAgent = IBridgeAgentFactory(_branchBridgeAgentFactory).createBridgeAgent( _newBranchRouter, _rootBridgeAgent, _rootBridgeAgentFactory ); if (!IPort(localPortAddress).isBridgeAgent(newBridgeAgent)) { revert UnrecognizedBridgeAgent(); } bytes memory data = abi.encode(newBridgeAgent, _rootBridgeAgent); bytes memory packedData = abi.encodePacked(bytes1(0x04), data); IBridgeAgent(localBridgeAgentAddress).performSystemCallOut(address(this), packedData, 0, 0); }``

- Estimated gas saved = 5,000-20,000 per call. ``SLOAD`` is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``_receiveAddBridgeAgent`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in UlyssesToken.sol
Scope = [UlyssesToken.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesToken.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesToken.sol#L110C1-L121C6
--  The ``updateAssetBalances`` function in ``UlyssesToken.sol`` involves multiple calls to ``assets[i].balanceOf(address(this))`` and ``assets[i].safeTransferFrom(msg.sender, address(this), newAssetBalance - assetBalance)``. These calls are used to get the balance of the contract and to transfer tokens from the sender to the contract. A possible optimization could be to store the balance in a local variable and use it in all function calls, reducing the number of calls to ``balanceOf`` and ``safeTransferFrom`` from two to one. To do this, update the ``updateAssetBalances`` function like so ``function updateAssetBalances() internal {
    for (uint256 i = 0; i < assets.length; i++) {
        uint256 assetBalance = assets[i].balanceOf(address(this));
        uint256 newAssetBalance = totalSupply.mulDivUp(weights[i], totalWeights);
        uint256 balanceDifference = newAssetBalance - assetBalance;
        if (assetBalance > newAssetBalance) {
            assets[i].safeTransfer(msg.sender, balanceDifference);
        } else {
            assets[i].safeTransferFrom(msg.sender, address(this), balanceDifference);
        }
    }
}``

- Estimated gas saved = 500-1,000 per call. ``SLOAD`` is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``updateAssetBalances`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in BranchBridgeAgentExecutor.sol
Scope = [BranchBridgeAgentExecutor.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgentExecutor.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgentExecutor.sol#L125C5-L157C6
-- The ``executeWithSettlement`` and ``executeWithSettlementMultiple`` functions in ``BranchBridgeAgentExecutor.sol`` involve multiple calls to ``BranchBridgeAgent(payable(msg.sender)).clearToken`` and ``BranchBridgeAgent(payable(msg.sender)).clearTokens`` respectively. These calls are used to clear tokens and save deposit parameters. A possible gas optimization could be to store the returned values in local variables and use them in the function calls, reducing the number of calls to ``clearToken`` and ``clearTokens`` from two to one. To do this, update the ``executeWithSettlement`` and ``executeWithSettlementMultiple`` functions like this ``function executeWithSettlement(address _recipient, address _router, bytes calldata _data)
    external
    onlyOwner
    returns (bool success, bytes memory result)
{
    //Clear Token / Execute Settlement
    SettlementParams memory sParams = SettlementParams({
        settlementNonce: uint32(bytes4(_data[PARAMS_START_SIGNED:25])),
        recipient: _recipient,
        hToken: address(uint160(bytes20(_data[25:45]))),
        token: address(uint160(bytes20(_data[45:65]))),
        amount: uint256(bytes32(_data[65:97])),
        deposit: uint256(bytes32(_data[97:129]))
    });
    //Bridge In Assets
    BranchBridgeAgent agent = BranchBridgeAgent(payable(msg.sender));
    agent.clearToken(
        sParams.recipient, sParams.hToken, sParams.token, sParams.amount, sParams.deposit
    );
    if (_data.length - PARAMS_GAS_OUT > 129) {
        //Execute remote request
        (success, result) = IRouter(_router).anyExecuteSettlement(_data[129:_data.length - PARAMS_GAS_OUT], sParams);
    } else {
        success = true;
    }
}`` and ``function executeWithSettlementMultiple(address _recipient, address _router, bytes calldata _data)
    external
    onlyOwner
    returns (bool success, bytes memory result)
{
    BranchBridgeAgent bridgeAgent = BranchBridgeAgent(payable(msg.sender));
    //Bridge In Assets and Save Deposit Params
    SettlementMultipleParams memory sParams = bridgeAgent.clearTokens(
        _data[
            PARAMS_START_SIGNED:
                PARAMS_START_SIGNED + PARAMS_TKN_START
                    + (uint8(bytes1(_data[PARAMS_START_SIGNED])) * uint16(PARAMS_TKN_SET_SIZE))
        ],
        _recipient
    );
    // Execute Calldata if any
    if (
        _data.length - PARAMS_GAS_OUT
            > PARAMS_START_SIGNED + PARAMS_TKN_START
                + (uint8(bytes1(_data[PARAMS_START_SIGNED])) * uint16(PARAMS_TKN_SET_SIZE))
    ) {
        //Try to execute remote request
        (success, result) = IRouter(_router).anyExecuteSettlementMultiple(
            _data[
                PARAMS_END_SIGNED_OFFSET + (uint8(bytes1(_data[PARAMS_START_SIGNED])) * uint16(PARAMS_TKN_SET_SIZE)):
                    _data.length - PARAMS_GAS_OUT
            ],
            sParams
        );
    } else {
        success = true;
    }
}``

- Estimated gas saved = 500-1,000 per call. ``SLOAD`` is expensive in terms of gas, reducing the number of ``SLOAD`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``executeWithSettlement`` and ``executeWithSettlementMultiple`` functions. If these functions are called frequently, the gas savings could be significant.

### Possible Optimizations in BaseV2GaugeManager.sol
Scope = [BaseV2GaugeManager.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol#L73C2-L87C6
-- The ``newEpoch`` function in ``BaseV2GaugeManager.sol`` involves a loop over all gauge factories to call ``newEpoch`` on each. This could be optimized by using a mapping to track active gauge factories and only looping over those. This would reduce the number of iterations and thus save gas. To do this, update the ``newEpoch`` function like this ``function newEpoch() external {
    uint256 length = gaugeFactories.length;
    for (uint256 i = 0; i < length;) {
        BaseV2GaugeFactory gaugeFactory = gaugeFactories[i];
        if (activeGaugeFactories[gaugeFactory]) gaugeFactory.newEpoch();
        unchecked {
            i++;
        }
    }
}``
- Estimated gas saved = 500-1,000 per call. The exact amount of gas saved will depend on the number of inactive gauge factories. If there are many inactive gauge factories, the gas savings could be significant.

Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/gauges/factories/BaseV2GaugeManager.sol#L110C5-L119C1
-- Similarly the ``addGaugeFactory`` function involves a check if the gauge factory already exists. This could be optimized by using a mapping to track gauge factories and only adding those that don't exist yet. This would reduce the number of storage operations and thus save gas. To do this, update the ``addGaugeFactory`` function like this ``function addGaugeFactory(BaseV2GaugeFactory gaugeFactory) external onlyOwner {
    require(!activeGaugeFactories[gaugeFactory], "GaugeFactoryAlreadyExists");
    gaugeFactoryIds[gaugeFactory] = gaugeFactories.length;
    gaugeFactories.push(gaugeFactory);
    activeGaugeFactories[gaugeFactory] = true;
    emit AddedGaugeFactory(address(gaugeFactory));
}``

- Estimated gas saved = 5,000-20,000 per call. ``SSTORE`` is expensive in terms of gas, reducing the number of ``SSTORE`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``addGaugeFactory`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in BranchBridgeAgentFactory.sol
Scope = [BranchBridgeAgentFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/BranchBridgeAgentFactory.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/BranchBridgeAgentFactory.sol#L113C4-L140C6
-- A possible optimization here could be to use the contract cloning technique mentioned earlier, the EIP-1167 minimal proxy pattern, to create new ``BranchBridgeAgent`` contracts. This would significantly reduce the gas cost of deploying new contracts. To do this, you would need to deploy a ``BranchBridgeAgent`` implementation contract once and then use the ``EIP-1167`` pattern to clone this contract whenever a new ``BranchBridgeAgent`` is needed. The ``createBridgeAgent`` function would then look like this ``function createBridgeAgent(
    address _newBranchRouterAddress,
    address _rootBridgeAgentAddress,
    address _rootBridgeAgentFactoryAddress
) external virtual returns (address newBridgeAgent) {
    require(
        msg.sender == localCoreBranchRouterAddress, "Only the Core Branch Router can create a new Bridge Agent."
    );
    require(
        _rootBridgeAgentFactoryAddress == rootBridgeAgentFactoryAddress,
        "Root Bridge Agent Factory Address does not match."
    );
    bytes20 targetBytes = bytes20(address(branchBridgeAgentImplementation));
    assembly {
        let clone := mload(0x40)
        mstore(
            clone,
            0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000
        )
        mstore(add(clone, 0x14), targetBytes)
        mstore(
            add(clone, 0x28),
            0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000
        )
        newBridgeAgent := create(0, clone, 0x37)
    }
    BranchBridgeAgent(newBridgeAgent).initialize(
        wrappedNativeToken,
        rootChainId,
        localChainId,
        _rootBridgeAgentAddress,
        localAnyCallAddress,
        localAnyCallExecutorAddress,
        _newBranchRouterAddress,
        localPortAddress
    );
    IPort(localPortAddress).addBridgeAgent(newBridgeAgent);
}``

- Estimated gas saved = 1,000,000-2,000,000 per call. Deploying a contract is expensive in terms of gas, and the EIP-1167 minimal proxy pattern can significantly reduce this cost. The exact amount of gas saved will depend on the size of the ``BranchBridgeAgent`` contract.

### Possible Optimization in BaseV2Minter.sol
Scope = [BaseV2Minter.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L123C5-L155C6
--  The ``updatePeriod`` function in ``BaseV2Minter.sol`` involves a check if a new week has started and if so, it calculates the new weekly emission, mints new tokens if needed, and transfers them to the vault and DAO. This function could be optimized by splitting it into two functions: one for checking if a new week has started and another for calculating and transferring the new emissions like ``calculateAndTransferEmissions`` below. This would allow the expensive operations to be skipped if a new week has not started yet. The new ``updatePeriod`` function would look like this ``function updatePeriod() public returns (uint256) {
    uint256 _period = activePeriod;
    // only trigger if new week
    if (block.timestamp >= _period + week && initializer == address(0)) {
        _period = (block.timestamp / week) * week;
        activePeriod = _period;
        calculateAndTransferEmissions();
    }
    return _period;
}`` then ``function calculateAndTransferEmissions() internal {
    uint256 newWeeklyEmission = weeklyEmission();
    weekly += newWeeklyEmission;
    uint256 _circulatingSupply = circulatingSupply();
    uint256 _growth = calculateGrowth(newWeeklyEmission);
    uint256 _required = _growth + newWeeklyEmission;
    // share of newWeeklyEmission emissions sent to DAO.
    uint256 share = (_required * daoShare) / base;
    _required += share;
    uint256 _balanceOf = underlying.balanceOf(address(this));
    if (_balanceOf < _required) {
        HERMES(underlying).mint(address(this), _required - _balanceOf);
    }
    underlying.safeTransfer(address(vault), _growth);
    if (dao != address(0)) underlying.safeTransfer(dao, share);
    emit Mint(msg.sender, newWeeklyEmission, _circulatingSupply, _growth, share);
}``

- Estimated gas saved = 10,000-30,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``updatePeriod`` function when a new week has not started yet. If this function is called frequently, the gas savings could be significant.

### Possible Optimization in BoostAggregator.sol
Scope = [BoostAggregator.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L109C5-L136C6
--  The ``unstakeAndWithdraw`` function in ``BoostAggregator.sol`` involves a check if the ``pendingRewards`` is greater than ``DIVISIONER`` and if so, it calculates the ``newProtocolRewards``, updates the ``protocolRewards``, and reduces the ``pendingRewards``. This could be optimized by using a conditional operator to calculate the ``newProtocolRewards`` and update the ``protocolRewards`` and ``pendingRewards`` in one line. This would reduce the number of storage operations and thus save gas. To do this, update the ``unstakeAndWithdraw`` function like this ``function unstakeAndWithdraw(uint256 tokenId) external {
    address user = tokenIdToUser[tokenId];
    if (user != msg.sender) revert NotTokenIdOwner();
    // unstake NFT from Uniswap V3 Staker
    uniswapV3Staker.unstakeToken(tokenId);
    uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];
    if (pendingRewards > DIVISIONER) {
        uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;
        // update protocolRewards and pendingRewards in one line
        protocolRewards += newProtocolRewards;
        pendingRewards -= newProtocolRewards;
        address rewardsDepot = userToRewardsDepot[user];
        if (rewardsDepot != address(0)) {
            // claim rewards to user's rewardsDepot
            uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);
        } else {
            // claim rewards to user
            uniswapV3Staker.claimReward(user, pendingRewards);
        }
    }
    // withdraw rewards from Uniswap V3 Staker
    uniswapV3Staker.withdrawToken(tokenId, user, "");
}
``
- Estimated gas saved = 5,000-10,000 per call. SSTORE is expensive in terms of gas, reducing the number of ``SSTORE`` operations can save a significant amount of gas. The exact amount of gas saved will depend on the frequency of calls to the ``unstakeAndWithdraw`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in BaseBranchRouter.sol
Scope = [BaseBranchRouter.sol](https://github.com/code-423n4/2023-05-maia/blob/main/contracts/BaseBranchRouter.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BaseBranchRouter.sol#L58C3-L62C6
-- The ``callOut`` function in ``BaseBranchRouter.sol`` involves a call to ``performCallOut`` function of the ``IBridgeAgent`` contract. This could be optimized by storing the ``IBridgeAgent`` contract instance in a local variable and reusing it. This would reduce the number of calls to ``IBridgeAgent`` and thus save gas. To do this, update the ``callOut`` function like this ``function callOut(bytes calldata params, uint128 remoteExecutionGas) external payable lock {
    IBridgeAgent bridgeAgent = IBridgeAgent(localBridgeAgentAddress);
    bridgeAgent.performCallOut{value: msg.value}(msg.sender, params, 0, remoteExecutionGas);
}``

- Estimated gas saved = 500-1,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``callOut`` function. If this function is called frequently, the gas savings could be significant.

Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BaseBranchRouter.sol#L65C2-L73C6
--  Similarly, the ``callOutAndBridge`` function involves a call to ``performCallOutAndBridge`` function of the ``IBridgeAgent`` contract. This could be optimized by storing the ``IBridgeAgent`` contract instance in a local variable also and reusing it. This would reduce the number of calls to ``IBridgeAgent`` and thus save gas. To do this, update the ``callOutAndBridge`` function like this ``function callOutAndBridge(bytes calldata params, DepositInput memory dParams, uint128 remoteExecutionGas)
    external
    payable
    lock
{
    IBridgeAgent bridgeAgent = IBridgeAgent(localBridgeAgentAddress);
    bridgeAgent.performCallOutAndBridge{value: msg.value}(msg.sender, params, dParams, 0, remoteExecutionGas);
}``

- Estimated gas saved = 500-1,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``callOutAndBridge`` function. If this function is called frequently, the gas savings could be significant. 

### Possible Optimizations in TalosStrategyVanilla.sol
Scope = [TalosStrategyVanilla.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L104C1-L125C6
-- The ``_earnFees`` function in ``TalosStrategyVanilla.sol`` involves a call to ``nonfungiblePositionManager.collect`` function. This could be optimized by storing the ``nonfungiblePositionManager`` contract instance in a local variable and reusing it. This would reduce the number of calls to ``nonfungiblePositionManager`` and thus save gas. To do this, update the ``_earnFees`` function like this ``function _earnFees(uint256 _tokenId) internal {
    if (liquidity == 0) return; // no fees to collect when liquidity is zero
    INonfungiblePositionManager nonfungiblePositionManagerInstance = nonfungiblePositionManager;
    (uint256 collect0, uint256 collect1) = nonfungiblePositionManagerInstance.collect(
        INonfungiblePositionManager.CollectParams({
            tokenId: _tokenId,
            recipient: address(this),
            amount0Max: type(uint128).max,
            amount1Max: type(uint128).max
        })
    );
    uint24 _protocolFee = protocolFee;
    uint24 _GLOBAL_DIVISIONER = GLOBAL_DIVISIONER;
    // Calculate protocol's fees
    uint256 earnedProtocolFees0 = (collect0 * _protocolFee) / _GLOBAL_DIVISIONER;
    uint256 earnedProtocolFees1 = (collect1 * _protocolFee) / _GLOBAL_DIVISIONER;
    protocolFees0 += earnedProtocolFees0;
    protocolFees1 += earnedProtocolFees1;
    emit CollectFees(earnedProtocolFees0, earnedProtocolFees1, collect0, collect1);
}``
- Estimated gas saved = 500-1,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``_earnFees`` function. If this function is called frequently, the gas savings could be significant.
Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L129C2-L154C6
--  Similarly, the ``_compoundFees`` function involves a call to ``nonfungiblePositionManager.increaseLiquidity`` function. This could be better optimized by storing the ``nonfungiblePositionManager`` contract instance in a local variable and reusing it. This would reduce the number of calls to ``nonfungiblePositionManager`` and thus save gas. To do this, update the ``_compoundFees`` function like this ``function _compoundFees(uint256 _tokenId) internal returns (uint256 amount0, uint256 amount1) {
    uint256 balance0 = token0.balanceOf(address(this)) - protocolFees0;
    uint256 balance1 = token1.balanceOf(address(this)) - protocolFees1;
    emit Snapshot(balance0, balance1);
    //Get Liquidity for Optimizer's balances
    uint128 _liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);
    // Add liquidity to the pool
    if (_liquidity > 0) {
        INonfungiblePositionManager nonfungiblePositionManagerInstance = nonfungiblePositionManager;
        uint128 liquidityDifference;
        (liquidityDifference, amount0, amount1) = nonfungiblePositionManagerInstance.increaseLiquidity(
            INonfungiblePositionManager.IncreaseLiquidityParams({
                tokenId: _tokenId,
                amount0Desired: balance0,
                amount1Desired: balance1,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            })
        );
        liquidity += liquidityDifference;
    }
}``

- Estimated gas saved = 500-1,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``_compoundFees`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in UlyssesFactory.sol
Scope = [UlyssesFactory.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/factories/UlyssesFactory.sol)
Possible Optimizations = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/factories/UlyssesFactory.sol#L91C5-L130C6
-- - The ``createPools`` function in ``UlyssesFactory.sol`` involves three separate loops for creating pools, adding bandwidth, and transferring ownership. This could be optimized by combining these operations into a single loop. This would reduce the number of iterations and thus save gas. To do this, update the ``createPools`` function like this ``function createPools(ERC20[] calldata assets, uint8[][] calldata weights, address owner)
    external
    returns (uint256[] memory poolIds)
{
    uint256 length = assets.length;
    if (length != weights.length) revert ParameterLengthError();
    for (uint256 i = 0; i < length; i++) {
        poolIds[i] = _createPool(assets[i], address(this));
        if (length != weights[i].length) revert ParameterLengthError();
        for (uint256 j = 0; j < length; j++) {
            if (j != i && weights[i][j] > 0) pools[poolIds[i]].addNewBandwidth(poolIds[j], weights[i][j]);
        }
        pools[poolIds[i]].transferOwnership(owner);
    }
}``

- Estimated gas saved = 5,000-10,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``createPools ``function and the number of pools being created. If this function is called frequently and a large number of pools are being created, the gas savings could be significant.

### Possible Optimization in ArbitrumBranchPort.sol
Scope = [ArbitrumBranchPort.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L45C2-L73C6
-- In the ``depositToPort`` and ``withdrawFromPort`` functions, the ``rootPortAddress`` state variable is accessed multiple times. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``rootPortAddress`` in a local variable and reusing it, do this for ``depositToPort`` like this ``function depositToPort(address _depositor, address _recipient, address _underlyingAddress, uint256 _deposit)
    external
    requiresBridgeAgent
{
    IRootPort rootPort = IRootPort(rootPortAddress);
    address globalToken = rootPort.getLocalTokenFromUnder(_underlyingAddress, localChainId);
    if (globalToken == address(0)) revert UnknownUnderlyingToken();
    _underlyingAddress.safeTransferFrom(_depositor, address(this), _deposit);
    rootPort.mintToLocalBranch(_recipient, globalToken, _deposit);
}
`` and for ``withdrawFromPort``, ``function withdrawFromPort(address _depositor, address _recipient, address _globalAddress, uint256 _deposit)
    external
    requiresBridgeAgent
{
    IRootPort rootPort = IRootPort(rootPortAddress);
    if (!rootPort.isGlobalToken(_globalAddress, localChainId)) {
        revert UnknownToken();
    }
    address underlyingAddress = rootPort.getUnderlyingTokenFromLocal(_globalAddress, localChainId);
    if (underlyingAddress == address(0)) revert UnknownUnderlyingToken();
    rootPort.burnFromLocalBranch(_depositor, _globalAddress, _deposit);
    underlyingAddress.safeTransfer(_recipient, _denormalizeDecimals(_deposit, ERC20(underlyingAddress).decimals()));
}
``
- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``depositToPort`` and ``withdrawFromPort`` functions.
Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L129C3-L154C6
-- The ``bridgeOutMultiple`` function involves a loop for bridging out multiple assets. This could be optimized by using a single call to ``safeTransferFrom`` and ``bridgeToRootFromLocalBranch`` for each asset. This would reduce the number of calls to these functions and thus save gas. To do this, update the ``bridgeOutMultiple`` function like this ``function bridgeOutMultiple(
    address _depositor,
    address[] memory _localAddresses,
    address[] memory _underlyingAddresses,
    uint256[] memory _amounts,
    uint256[] memory _deposits
) external override(IBranchPort, BranchPort) requiresBridgeAgent {
    uint256 length = _localAddresses.length;
    for (uint256 i = 0; i < length; i++) {
        if (_deposits[i] > 0) {
            _underlyingAddresses[i].safeTransferFrom(
                _depositor,
                address(this),
                _denormalizeDecimals(_deposits[i], ERC20(_underlyingAddresses[i]).decimals())
            );
        }
        if (_amounts[i] - _deposits[i] > 0) {
            IRootPort(rootPortAddress).bridgeToRootFromLocalBranch(
                _depositor, _localAddresses[i], _amounts[i] - _deposits[i]
            );
        }
    }
}``
- Estimated gas saved = 5,000-10,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``bridgeOutMultiple`` function and the number of assets being bridged out. If this function is called frequently and a large number of assets are being bridged out, the gas savings could be significant.

### Possible Optimizations in ArbitrumBranchBridgeAgent.sol
Scope = [ArbitrumBranchBridgeAgent.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L102C3-L116C6
--  Similar to last optimization the ``depositToPort`` and ``withdrawFromPort`` functions, the ``localPortAddress`` state variable is accessed multiple times. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``localPortAddress`` in a local variable and reusing it, do this for ``depositToPort`` like this ``function depositToPort(address underlyingAddress, uint256 amount) external payable lock { IArbPort localPort = IArbPort(localPortAddress); localPort.depositToPort( msg.sender, msg.sender, underlyingAddress, _normalizeDecimals(amount, ERC20(underlyingAddress).decimals()) ); }`` and for ``withdrawFromPort``, ``function withdrawFromPort(address localAddress, uint256 amount) external payable lock { IArbPort localPort = IArbPort(localPortAddress); localPort.withdrawFromPort(msg.sender, msg.sender, localAddress, amount); }``
- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``depositToPort`` and ``withdrawFromPort`` functions.
Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L142C2-L144C6
-- The ``_performCall`` function involves a call to ``anyExecute`` function of the ``IRootBridgeAgent`` contract. This could be optimized by storing the ``IRootBridgeAgent`` contract instance in a local variable and reusing it. This would reduce the number of calls to ``IRootBridgeAgent`` and thus save gas. To do this, update the ``_performCall`` function like this ``function _performCall(bytes memory _callData) internal override { IRootBridgeAgent rootBridgeAgent = IRootBridgeAgent(rootBridgeAgentAddress); rootBridgeAgent.anyExecute(_callData); }``
- Estimated gas saved = 500-1,000 per call. The exact amount of gas saved will depend on the frequency of calls to the ``_performCall`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimization in TalosStrategyStaked.sol
Scope = [TalosStrategyStaked.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L89C2-L97C6
-- In the ``transfer`` and ``transferFrom`` functions, the ``flywheel`` state variable is accessed. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``flywheel`` in a local variable and reusing it, do this for transfer like this ``function transfer(address _to, uint256 _amount) public override returns (bool) {
    FlywheelCoreInstant flywheelInstance = flywheel;
    flywheelInstance.accrue(ERC20(address(this)), msg.sender, _to);
    return super.transfer(_to, _amount);
}`` and for ``transferFrom``, ``function transferFrom(address _from, address _to, uint256 _amount) public override returns (bool) {
    FlywheelCoreInstant flywheelInstance = flywheel;
    flywheelInstance.accrue(ERC20(address(this)), _from, _to);
    return super.transferFrom(_from, _to, _amount);
}``

- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``transfer`` and ``transferFrom`` functions.

Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L101C3-L104C6 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L114C4-L117C6 https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyStaked.sol#L127C2-L130C6
-- The beforeRedeem, beforeDeposit, beforeRerange functions involve a call to _earnFees function. This could be optimized by storing the flywheel contract instance in a local variable and reusing it. This would reduce the number of calls to flywheel and thus save gas. To do this, update the beforeRedeem, beforeDeposit, beforeRerange functions like this ``function beforeRedeem(uint256 _tokenId, address _owner) internal override {
    FlywheelCoreInstant flywheelInstance = flywheel;
    _earnFees(_tokenId);
    flywheelInstance.accrue(_owner);
}``, ``function beforeDeposit(uint256 _tokenId, address _receiver) internal override {
    FlywheelCoreInstant flywheelInstance = flywheel;
    _earnFees(_tokenId);
    flywheelInstance.accrue(_receiver);
}``. ``function beforeRerange(uint256 _tokenId) internal override {
    FlywheelCoreInstant flywheelInstance = flywheel;
    _earnFees(_tokenId);
    flywheelInstance.accrue(msg.sender);
}`` 
- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``beforeRedeem``, ``beforeDeposit``, ``beforeRerange`` functions. If these functions are called frequently, the gas savings could be significant.

### Possible Optimizations in FlywheelGaugeRewards.sol
Scope = [FlywheelGaugeRewards.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelGaugeRewards.sol#L72C4-L156C6
-- In the ``queueRewardsForCycle`` and ``queueRewardsForCyclePaginated`` functions, the ``minter`` state variable is accessed multiple times. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing minter in a local variable and reusing it, do this for ``queueRewardsForCycle`` like this ``function queueRewardsForCycle() external returns (uint256 totalQueuedForCycle) {
    IBaseV2Minter minterInstance = minter;
    minterInstance.updatePeriod();
    uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;
    uint32 lastCycle = gaugeCycle;
    if (currentCycle <= lastCycle) revert CycleError();
    gaugeCycle = currentCycle;
    uint256 balanceBefore = rewardToken.balanceOf(address(this));
    totalQueuedForCycle = minterInstance.getRewards();
    require(rewardToken.balanceOf(address(this)) - balanceBefore >= totalQueuedForCycle);
    address[] memory gauges = gaugeToken.gauges();
    _queueRewards(gauges, currentCycle, lastCycle, totalQueuedForCycle);
    nextCycleQueuedRewards = 0;
    paginationOffset = 0;
    emit CycleStart(currentCycle, totalQueuedForCycle);
}`` and for ``queueRewardsForCyclePaginated``, ``function queueRewardsForCyclePaginated(uint256 numRewards) external {
    IBaseV2Minter minterInstance = minter;
    minterInstance.updatePeriod();
    uint32 currentCycle = (block.timestamp.toUint32() / gaugeCycleLength) * gaugeCycleLength;
    uint32 lastCycle = gaugeCycle;
    if (currentCycle <= lastCycle) revert CycleError();
    if (currentCycle > nextCycle) {
        nextCycle = currentCycle;
        paginationOffset = 0;
    }
    uint32 offset = paginationOffset;
    if (offset == 0) {
        uint256 balanceBefore = rewardToken.balanceOf(address(this));
        uint256 newRewards = minterInstance.getRewards();
        require(rewardToken.balanceOf(address(this)) - balanceBefore >= newRewards);
        require(newRewards <= type(uint112).max); // safe cast
        nextCycleQueuedRewards += uint112(newRewards); // in case a previous incomplete cycle had rewards, add on
    }
    uint112 queued = nextCycleQueuedRewards;
    uint256 remaining = gaugeToken.numGauges() - offset;
    if (remaining <= numRewards) {
        numRewards = remaining;
        gaugeCycle = currentCycle;
        nextCycleQueuedRewards = 0;
        paginationOffset = 0;
        emit CycleStart(currentCycle, queued);
    } else {
        paginationOffset += uint32(numRewards);
    }
    address[] memory gauges = gaugeToken.gauges(offset, numRewards);
    _queueRewards(gauges, currentCycle, lastCycle, queued);
}``
- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``queueRewardsForCycle`` and ``queueRewardsForCyclePaginated`` functions. If these functions are called frequently, the gas savings could be significant.

### Possible Optimizations in CoreBranchRouter.sol
Scope = [CoreBranchRouter.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/CoreBranchRouter.sol)
Possible Optimizations = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/CoreBranchRouter.sol#L41C5-L79C6
-- In the ``addGlobalToken`` and ``addLocalToken`` functions, the ``localBridgeAgentAddress`` state variable is accessed multiple times. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``localBridgeAgentAddress`` in a local variable and reusing it, do this for ``addGlobalToken`` like this ``function addGlobalToken( address _globalAddress, uint24 _toChain, uint128 _remoteExecutionGas, uint128 _rootExecutionGas ) external payable { address localBridgeAgentAddressInstance = localBridgeAgentAddress; //Encode Call Data bytes memory data = abi.encode(msg.sender, _globalAddress, _toChain, _rootExecutionGas); //Pack FuncId bytes memory packedData = abi.encodePacked(bytes1(0x01), data); //Send Cross-Chain request (System Response/Request) IBridgeAgent(localBridgeAgentAddressInstance).performCallOut{value: msg.value}( msg.sender, packedData, 0, _remoteExecutionGas ); }`` and for ``addLocalToken``, ``function addLocalToken(address _underlyingAddress) external payable virtual { address localBridgeAgentAddressInstance = localBridgeAgentAddress; //Get Token Info string memory name = ERC20(_underlyingAddress).name(); string memory symbol = ERC20(_underlyingAddress).symbol(); //Create Token ERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(name, symbol); //Encode Data bytes memory data = abi.encode(_underlyingAddress, newToken); //Pack FuncId bytes memory packedData = abi.encodePacked(bytes1(0x02), data); //Send Cross-Chain request (System Response/Request) IBridgeAgent(localBridgeAgentAddressInstance).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0); }``
- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``addGlobalToken`` and ``addLocalToken`` functions. If these functions are called frequently, the gas savings could be significant.

### Possible Optimization in CoreRootRouter.sol
Scope = [CoreRootRouter.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/CoreRootRouter.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/CoreRootRouter.sol#L81C5-L116C6
-- In the ``addBranchToBridgeAgent`` function, the ``bridgeAgentAddress`` state variable is accessed. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``bridgeAgentAddress`` in a local variable and reusing it, do this for ``addBranchToBridgeAgent`` like this ``function addBranchToBridgeAgent( address _rootBridgeAgent, address _branchBridgeAgentFactory, address _newBranchRouter, address _gasReceiver, uint24 _toChain, uint128 _remoteExecutionGas ) external payable { address payable bridgeAgentAddressInstance = bridgeAgentAddress; // Check if msg.sender is the Bridge Agent Manager if (msg.sender != IPort(rootPortAddress).getBridgeAgentManager(_rootBridgeAgent)) { revert UnauthorizedCallerNotManager(); } //Check if valid chain if (!IPort(rootPortAddress).isChainId(_toChain)) revert InvalidChainId(); //Check if chain already added to bridge agent if (IBridgeAgent(_rootBridgeAgent).getBranchBridgeAgent(_toChain) != address(0)) revert InvalidChainId(); //Check if Branch Bridge Agent is allowed by Root Bridge Agent if (!IBridgeAgent(_rootBridgeAgent).isBranchBridgeAgentAllowed(_toChain)) revert UnauthorizedChainId(); //Root Bridge Agent Factory Address address rootBridgeAgentFactory = IBridgeAgent(_rootBridgeAgent).factoryAddress(); //Encode CallData bytes memory data = abi.encode( _newBranchRouter, _branchBridgeAgentFactory, _rootBridgeAgent, rootBridgeAgentFactory, _remoteExecutionGas ); //Pack funcId into data bytes memory packedData = abi.encodePacked(bytes1(0x02), data); //Add new global token to branch chain IBridgeAgent(bridgeAgentAddressInstance).callOut{value: msg.value}(_gasReceiver, packedData, _toChain); }``
- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``addBranchToBridgeAgent`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in BranchPort.sol
Scope = [BranchPort.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol)
Possible Optimization 1 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L99C1-L110C6
--  In the ``initialize`` function, the ``coreBranchRouterAddress`` and ``isBridgeAgentFactory`` state variables are accessed. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``coreBranchRouterAddress`` and ``isBridgeAgentFactory`` in local variables and reusing them, do this for ``initialize`` like so ``function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner { address coreBranchRouterAddressInstance = coreBranchRouterAddress; bool isBridgeAgentFactoryInstance = isBridgeAgentFactory[_bridgeAgentFactory]; require(coreBranchRouterAddressInstance == address(0), "Contract already initialized"); require(!isBridgeAgentFactoryInstance, "Contract already initialized"); require(_coreBranchRouter != address(0), "CoreBranchRouter is zero address"); require(_bridgeAgentFactory != address(0), "BridgeAgentFactory is zero address"); coreBranchRouterAddress = _coreBranchRouter; isBridgeAgentFactory[_bridgeAgentFactory] = true; bridgeAgentFactories.push(_bridgeAgentFactory); bridgeAgentFactoriesLenght++; }``
- Estimated gas saved = 800 gas. 
Possible Optimization 2 = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L137C1-L151C6
-- - In the ``_excessReserves`` and ``_reservesLacking`` functions, the ``ERC20(_token).balanceOf(address(this))`` is accessed twice. Each ``CALL`` operation consumes 700 gas. We can reduce the gas consumption by storing the balance in a local variable and reusing it, do this for ``_excessReserves`` like so ``function _excessReserves(address _token) internal view returns (uint256) { uint256 currBalance = ERC20(_token).balanceOf(address(this)); uint256 minReserves = _minimumReserves(currBalance, _token); return currBalance > minReserves ? currBalance - minReserves : 0; } and for _reservesLacking, function _reservesLacking(address _token) internal view returns (uint256) { uint256 currBalance = ERC20(_token).balanceOf(address(this)); uint256 minReserves = _minimumReserves(currBalance, _token); return currBalance < minReserves ? minReserves - currBalance : 0; }``
- Estimated gas saved = 700 per call. The exact amount of gas saved will depend on the frequency of calls to the ``_excessReserves`` and ``_reservesLacking`` functions. If these functions are called frequently, the gas savings could be significant.

### Possible Optimization in RootBridgeAgentExecutor.sol
Scope = [RootBridgeAgentExecutor.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgentExecutor.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgentExecutor.sol#L117C1-L143C6
-- In the ``executeWithDeposit`` function, the ``_router`` address is used multiple times. Each ``CALL`` operation consumes 700 gas. We can reduce the gas consumption by storing ``_router`` in a local variable and reusing it, do this for ``executeWithDeposit`` like so ``function executeWithDeposit(address _router, bytes calldata _data, uint24 _fromChainId)
    external
    onlyOwner
    returns (bool success, bytes memory result)
{
    IRouter routerInstance = IRouter(_router);
    //Read Deposit Params
    DepositParams memory dParams = DepositParams({
        depositNonce: uint32(bytes4(_data[PARAMS_START:PARAMS_TKN_START])),
        hToken: address(uint160(bytes20(_data[PARAMS_TKN_START:25]))),
        token: address(uint160(bytes20(_data[25:45]))),
        amount: uint256(bytes32(_data[45:77])),
        deposit: uint256(bytes32(_data[77:109])),
        toChain: uint24(bytes3(_data[109:112]))
    });
    //Bridge In Assets
    _bridgeIn(routerInstance, dParams, _fromChainId);
    if (_data.length - PARAMS_GAS_IN > 112) {
        //Execute remote request
        (success, result) = routerInstance.anyExecuteDepositSingle(
            _data[112], _data[113:_data.length - PARAMS_GAS_IN], dParams, _fromChainId
        );
    } else {
        success = true;
    }
}``
- Estimated gas saved = 700 per call. The exact amount of gas saved will depend on the frequency of calls to the ``executeWithDeposit`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in MulticallRootRouter.sol
Scope = [MulticallRootRouter.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/MulticallRootRouter.sol)
Possible Optimizations = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/MulticallRootRouter.sol#L111C5-L158C6
--  In the ``_approveAndCallOut`` and ``_approveMultipleAndCallOut`` functions, the ``bridgeAgentAddress`` state variable is accessed. Each ``SLOAD`` operation consumes 800 gas. We can reduce the gas consumption by storing ``bridgeAgentAddress`` in a local variable and reusing it, do this for ``_approveAndCallOut`` like so ``function _approveAndCallOut( address owner, address recipient, address outputToken, uint256 amountOut, uint256 depositOut, uint24 toChain ) internal virtual { address payable bridgeAgentAddressInstance = bridgeAgentAddress; ERC20hTokenRoot(outputToken).approve(bridgeAgentAddressInstance, amountOut); IBridgeAgent(bridgeAgentAddressInstance).callOutAndBridge{value: msg.value}( owner, recipient, "", outputToken, amountOut, depositOut, toChain ); }`` and for ``_approveMultipleAndCallOut``, ``function _approveMultipleAndCallOut( address owner, address recipient, address[] memory outputTokens, uint256[] memory amountsOut, uint256[] memory depositsOut, uint24 toChain ) internal virtual { address payable bridgeAgentAddressInstance = bridgeAgentAddress; for (uint256 i = 0; i < outputTokens.length;) { ERC20hTokenRoot(outputTokens[i]).approve(bridgeAgentAddressInstance, amountsOut[i]); unchecked { ++i; } } IBridgeAgent(bridgeAgentAddressInstance).callOutAndBridge{value: msg.value}( owner, recipient, "", outputTokens, amountsOut, depositsOut, toChain ); }``

- Estimated gas saved = 800 per call. The exact amount of gas saved will depend on the frequency of calls to the ``_approveAndCallOut`` and ``_approveMultipleAndCallOut`` functions. If these functions are called frequently, the gas savings could be significant.
 
### Possible Optimization in GovernorBravoDelegateMaia.sol
Scope = [GovernorBravoDelegateMaia.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/governance/GovernorBravoDelegateMaia.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/governance/GovernorBravoDelegateMaia.sol#L104C5-L137C10
-- In the ``propose`` function, the ``govToken.getPriorVotes(msg.sender, sub256(block.number, 1))`` is accessed twice. Each ``CALL`` operation consumes 700 gas. We can reduce the gas consumption by storing the result in a local variable and reusing it, do this for propose like so ``function propose(
    address[] memory targets,
    uint256[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description
) public returns (uint256) {
    require(initialProposalId != 0, "GovernorBravo::propose: Governor Bravo not active");
    uint256 proposerVotes = govToken.getPriorVotes(msg.sender, sub256(block.number, 1));
    require(
        proposerVotes > getProposalThresholdAmount() || isWhitelisted(msg.sender),
        "GovernorBravo::propose: proposer votes below proposal threshold"
    );
    require(
        targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,
        "GovernorBravo::propose: proposal function information arity mismatch"
    );
    require(targets.length != 0, "GovernorBravo::propose: must provide actions");
    require(targets.length <= proposalMaxOperations, "GovernorBravo::propose: too many actions");
    uint256 latestProposalId = latestProposalIds[msg.sender];
    if (latestProposalId != 0) {
        ProposalState proposersLatestProposalState = state(latestProposalId);
        require(
            proposersLatestProposalState != ProposalState.Active,
            "GovernorBravo::propose: one live proposal per proposer, found an already active proposal"
        );
        require(
            proposersLatestProposalState != ProposalState.Pending,
            "GovernorBravo::propose: one live proposal per proposer, found an already pending proposal"
        );
    }
    uint256 startBlock = add256(block.number, votingDelay);
    uint256 endBlock = add256(startBlock, votingPeriod);
    proposalCount++;
    uint256 newProposalID = proposalCount;
    Proposal storage newProposal = proposals[newProposalID];
}``
- Estimated gas saved = 700 gas. The exact amount of gas saved will depend on the frequency of calls to the ``propose`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in UlyssesPool.sol
Scope = [UlyssesPool.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesPool.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesPool.sol#L126C1-L143C6
-- In the ``getProtocolFees`` function, the ``asset.balanceOf(address(this))`` is accessed twice. Each ``CALL`` operation consumes 700 gas. We can reduce the gas consumption by storing the result in a local variable and reusing it, do this for ``getProtocolFees`` like so ``function getProtocolFees() public view returns (uint256) {
    uint256 balance = asset.balanceOf(address(this));
    uint256 assets;
    for (uint256 i = 1; i < bandwidthStateList.length; i++) {
        uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);
        assets += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);
        assets += bandwidthStateList[i].bandwidth;
    }
    if (balance > assets) {
        return balance - assets;
    } else {
        return 0;
    }
}``
- Estimated gas saved = 700 gas. The exact amount of gas saved will depend on the frequency of calls to the ``getProtocolFees`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimization in RootBridgeAgent.sol
Scope = [RootBridgeAgent.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L50C1-L64C2
-- In the ``checkParams`` function, the ``IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain)`` and ``IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain)`` are external calls that can be optimized. Each external call consumes at least 700 gas. We can reduce the gas consumption by storing the result in a local variable and reusing it. Here is the optimized ``checkParams`` function ``function checkParams(address _localPortAddress, DepositParams memory _dParams, uint24 _fromChain)
    internal
    view
    returns (bool)
{
    bool isLocalToken = IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain);
    bool isUnderlyingToken = IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain);
    if (
        (_dParams.amount < _dParams.deposit) //Deposit can't be greater than amount.
            || (_dParams.amount > 0 && !isLocalToken) //Check local exists.
            || (_dParams.deposit > 0 && !isUnderlyingToken) //Check underlying exists.
    ) {
        return false;
    }
    return true;
}``
- Estimated gas saved = 1400 gas. The exact amount of gas saved will depend on the frequency of calls to the ``checkParams`` function. If this function is called frequently, the gas savings could be significant.

### Possible Optimizations in BranchBridgeAgent.sol
Scope = [BranchBridgeAgent.sol](https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol)
Possible Optimization = https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L141C4-L176C6
-- This is only a minor optimization, the constructor function has multiple ``require`` statements to check if the provided addresses are not zero. Each require statement consumes gas, and we can optimize this by combining all these checks into a single require statement using logical AND (&&). This will save gas by reducing the number of ``JUMPI`` operations, do this like so ``constructor(
    WETH9 _wrappedNativeToken,
    uint256 _rootChainId,
    uint256 _localChainId,
    address _rootBridgeAgentAddress,
    address _localAnyCallAddress,
    address _localAnyCallExecutorAddress,
    address _localRouterAddress,
    address _localPortAddress
) {
    require(
        _rootBridgeAgentAddress != address(0) &&
        _localAnyCallAddress != address(0) &&
        _localAnyCallExecutorAddress != address(0) &&
        _localRouterAddress != address(0),
        "Addresses cannot be the zero address."
    );
    // Rest of the constructor code...
}``
- Estimated gas saved = This optimization reduces the number of ``JUMPI`` operations from 4 to 1. Each ``JUMPI`` operation consumes 10 gas, so the total gas saved is 30 gas. 